<#@ template debug="false" hostspecific="true" language="C#" #>
<#+ void AddClasses(GenerationContext context){
var model = context.Model;
var settings = context.Settings;
var manager = context.Manager;
#>
<#+   
	if(!settings.PlaceContentsInSeparateFiles)
    {
		 manager.StartNewFile(model.Schema.ClassName + ".Contents"+".cs");
#>
// Code generated by a template
using System;
using System.Linq;
using System.Collections;
using System.Collections.Generic;
using Quantumart.QP8.EntityFrameworkCore;
<#+
	}
	 #>
<#+  foreach(var content in model.Contents) { #>	
<#+ 
    if(settings.PlaceContentsInSeparateFiles)
    {
		manager.StartNewFile(content.MappedName + ".cs"); #>
// Code generated by a template
using System;
using System.Linq;
using System.Collections;
using System.Collections.Generic;
using Quantumart.QP8.EntityFrameworkCore;
<#+
	}
#>
namespace <#=System.Runtime.Remoting.Messaging.CallContext.LogicalGetData("NamespaceHint")#>
{
    public partial class <#=content.MappedName #>: IQPArticle
    {
        public <#=content.MappedName #>()
        {
<#+	   	foreach(var attribute in content.Attributes.Where(x => x.IsM2O)) { #>
		    <#=attribute.MappedName#> = new HashSet<<#=attribute.RelatedContent.MappedName#>>();
<#+		} #>
<#+	   	foreach(var attribute in content.Attributes.Where(x => x.IsM2M)) { 
			if((attribute.IsSource == true) ||  (!settings.UseReversedAssociations || !attribute.Content.SplitArticles)) {
#>
		    <#=attribute.MappedName#> = new HashSet<<#=attribute.M2MClassName#>>();
<#+			} else {  #>
			<#=attribute.MappedName#> = new HashSet<<#=attribute.M2MReverseClassName#>>();
<#+			} #>
<#+		} #>
        }

        public virtual Int32 Id { get; set; }
        public virtual Int32 StatusTypeId { get; set; }
        public virtual bool Visible { get; set; }
        public virtual bool Archive { get; set; }
        public virtual DateTime Created { get; set; }
        public virtual DateTime Modified { get; set; }
        public virtual Int32 LastModifiedBy { get; set; }
        public virtual StatusType StatusType { get; set; }

<#+     foreach(var attribute in content.Attributes.Where(x => !x.IsM2M && !x.IsM2O && !x.IsO2M)) { 
			if(model.Schema.ReplaceUrls && attribute.CanContainPlaceholders) {
#>
		private <#= attribute.NetType#> _<#=attribute.MappedName#>;
		public virtual <#= attribute.NetType#> <#=attribute.MappedName#> 
		{ 
			get { return _<#=attribute.MappedName#>; }
			set { _<#=attribute.MappedName#> = <#=model.Schema.ClassName#>.Current.ReplacePlaceholders(value);}
		}
<#+			} else { #>
        public virtual <#= attribute.NetType#> <#=attribute.MappedName#> { get; set; }
<#+			} #>
<#+		} #>
<#+	   	foreach(var attribute in content.Attributes.Where(x => x.IsO2M)) { #>
		/// <summary>
		/// <#=attribute.Description??""#>
		/// </summary>			
		public virtual <#= attribute.RelatedContent.MappedName#> <#=attribute.MappedName#> { get; set; }
<#+		} #>
<#+	   	foreach(var attribute in content.Attributes.Where(x => x.IsO2M)) { #>
		/// <summary>
		/// <#=attribute.Description??""#>
		/// </summary>
		public virtual Int32? <#=attribute.OriginalMappedName#> { get; set; }
<#+		} #>
<#+	   	foreach(var attribute in content.Attributes.Where(x => x.IsM2O)) { #>
		/// <summary>
		/// <#=attribute.Description??""#>
		/// </summary>
		public <#+ if( settings.ProxyCreationEnabled ) { #> virtual <#+}#> ICollection<<#=attribute.RelatedContent.MappedName#>> <#=attribute.MappedName#> { get; set; }
<#+		} #>
<#+	   	foreach(var attribute in content.Attributes.Where(x => x.IsM2M)) { #>
		/// <summary>
		/// <#=attribute.Description??""#>
		/// </summary>
<#+		if(attribute.IsSource == true || (!settings.UseReversedAssociations || !attribute.Content.SplitArticles)) { #>
		public <#+ if( settings.ProxyCreationEnabled ) { #> virtual <#+}#> ICollection<<#=attribute.M2MClassName#>> <#=attribute.MappedName#> { get; set; }
<#+		} else { #>
		public <#+ if( settings.ProxyCreationEnabled ) { #> virtual <#+}#> ICollection<<#=attribute.M2MReverseClassName#>> <#=attribute.MappedName#> { get; set; }
<#+		} #>
<#+		} #>
	}
}
<#+}#>
<#+}#>